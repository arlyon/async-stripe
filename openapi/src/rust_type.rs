use std::fmt::{Debug, Display, Formatter};

use crate::components::Components;
use crate::rust_object::{ObjectMetadata, ObjectUsage, RustObject};
use crate::types::{ComponentPath, RustIdent};
use crate::visitor::{Visit, VisitMut};

/// A path to a type defined elsewhere.
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum PathToType {
    /// A top-level component.
    Component(ComponentPath),
    /// The id for a top-level component.
    ObjectId(ComponentPath),
    Shared(RustIdent),
    Deduplicated {
        path: ComponentPath,
        ident: RustIdent,
    },
}

impl PathToType {
    pub fn has_reference(&self, components: &Components) -> bool {
        match self {
            // NB: It would be more future-proof to query reference info
            // directly, e.g. `components.get(path).rust_obj().has_reference(components)`,
            // but this leads to infinite recursion because of the cyclical type definitions
            // in the spec. For now, `false` is always accurate, so is an easy workaround
            Self::Component(_) => false,

            // Always either backed by `String` or `smol_str::SmolStr`
            Self::ObjectId(_) => false,
            Self::Shared(ident) => components.get_extra_type(ident).obj.has_reference(components),
            Self::Deduplicated { path, ident } => {
                components.get_dedupped_type(ident, path).object.has_reference(components)
            }
        }
    }

    pub fn is_copy(&self, components: &Components) -> bool {
        match self {
            Self::Component(comp) => components.get(comp).rust_obj().is_copy(components),

            // Always either backed by `String` or `smol_str::SmolStr`
            Self::ObjectId(_) => false,
            Self::Shared(ident) => components.get_extra_type(ident).obj.is_copy(components),
            Self::Deduplicated { path, ident } => {
                components.get_dedupped_type(ident, path).object.is_copy(components)
            }
        }
    }
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum RustType {
    Object(RustObject, ObjectMetadata),
    /// A scalar type (meaning that does not contain another `RustType` internally, not that
    /// it may not be a collection), not generated by codegen.
    Simple(SimpleType),
    Path {
        path: PathToType,
        is_ref: bool,
    },
    /// Type containing an inner type.
    Container(Container),
}

impl RustType {
    pub const fn bool() -> Self {
        Self::Simple(SimpleType::Bool)
    }

    pub const fn float() -> Self {
        Self::Simple(SimpleType::Float)
    }

    pub const fn string() -> Self {
        Self::Simple(SimpleType::String)
    }

    pub const fn int(typ: IntType) -> Self {
        Self::Simple(SimpleType::Int(typ))
    }

    pub const fn ext(ext: ExtType) -> Self {
        Self::Simple(SimpleType::Ext(ext))
    }

    pub fn option(typ: Self) -> Self {
        Self::Container(Container::Option(Box::new(typ)))
    }

    pub fn boxed(typ: Self) -> Self {
        Self::Container(Container::Box(Box::new(typ)))
    }

    pub fn list(typ: Self) -> Self {
        Self::Container(Container::List(Box::new(typ)))
    }

    pub fn search_list(typ: Self) -> Self {
        Self::Container(Container::SearchList(Box::new(typ)))
    }

    /// Construct an `Expandable<{typ}>`.
    pub fn expandable(typ: Self) -> Self {
        Self::Container(Container::Expandable(Box::new(typ)))
    }

    /// Construct a `HashMap<String, {typ}>`.
    pub fn str_map(value: Self, is_ref: bool) -> Self {
        Self::Container(Container::Map { key: MapKey::String, value: Box::new(value), is_ref })
    }

    /// Construct a `HashMap<Currency, {typ}>`.
    pub fn currency_map(typ: Self, is_ref: bool) -> Self {
        Self::Container(Container::Map { key: MapKey::Currency, value: Box::new(typ), is_ref })
    }

    /// Construct a `Vec<{typ}>`.
    pub fn vec(typ: Self) -> Self {
        Self::Container(Container::Vec(Box::new(typ)))
    }

    /// Construct a `&[{typ}]`
    pub fn slice(typ: Self) -> Self {
        Self::Container(Container::Slice(Box::new(typ)))
    }

    pub fn path(path: PathToType, is_ref: bool) -> Self {
        Self::Path { path, is_ref }
    }

    /// Extract the component path from `{}Id` or `Option<{}Id>`
    pub fn as_id_or_opt_id_path(&self) -> Option<&ComponentPath> {
        match self {
            Self::Path { path: PathToType::ObjectId(path), .. } => Some(path),
            Self::Container(Container::Option(typ)) => match &**typ {
                Self::Path { path: PathToType::ObjectId(path), .. } => Some(path),
                _ => None,
            },
            _ => None,
        }
    }

    pub fn as_component_path(&self) -> Option<&ComponentPath> {
        match self {
            Self::Path { path: PathToType::Component(path), .. } => Some(path),
            _ => None,
        }
    }

    /// Is this type `Option<>`?
    pub const fn is_option(&self) -> bool {
        matches!(self, Self::Container(Container::Option(_)))
    }

    /// Can this type derive `Copy`?
    pub fn is_copy(&self, components: &Components) -> bool {
        use Container::*;

        match self {
            Self::Object(obj, ..) => obj.is_copy(components),
            Self::Simple(typ) => typ.is_copy(),
            Self::Path { path, is_ref } => *is_ref || path.is_copy(components),
            Self::Container(typ) => match typ {
                List(_) | Vec(_) | Expandable(_) | SearchList(_) => false,
                Slice(_) => true,
                Option(inner) | Box(inner) => inner.is_copy(components),
                Map { is_ref, .. } => *is_ref,
            },
        }
    }

    pub fn with_option_stripped(&self) -> &Self {
        match self {
            RustType::Container(Container::Option(inner)) => inner,
            _ => self,
        }
    }

    /// Does this contain a reference? Primarily used for detecting types that may
    /// require lifetimes.
    pub fn has_reference(&self, components: &Components) -> bool {
        match self {
            Self::Object(obj, ..) => obj.has_reference(components),
            Self::Simple(typ) => typ.is_reference(),
            Self::Path { path, is_ref } => *is_ref || path.has_reference(components),
            Self::Container(typ) => match typ {
                Container::Slice(_) => true,
                Container::Map { is_ref: true, .. } => true,
                _ => typ.value_typ().has_reference(components),
            },
        }
    }

    pub fn component_path(path: ComponentPath) -> Self {
        Self::path(PathToType::Component(path), false)
    }

    pub fn json_value() -> Self {
        Self::Simple(SimpleType::Ext(ExtType::Value))
    }

    pub fn object_id(id_path: ComponentPath, is_ref: bool) -> Self {
        Self::path(PathToType::ObjectId(id_path), is_ref)
    }

    pub fn into_nullable(self) -> Self {
        match self {
            Self::Container(Container::Option(_)) => self,
            _ => Self::option(self),
        }
    }

    /// Find any `RustObject` that may be contained in this type
    pub fn extract_object(&self) -> Option<(&RustObject, &ObjectMetadata)> {
        match self {
            Self::Object(obj, meta) => Some((obj, meta)),
            Self::Simple(_) | Self::Path { .. } => None,
            Self::Container(typ) => typ.value_typ().extract_object(),
        }
    }

    pub fn as_object(&self) -> Option<(&RustObject, &ObjectMetadata)> {
        match self {
            Self::Object(obj, meta) => Some((obj, meta)),
            _ => None,
        }
    }

    pub fn as_object_mut(&mut self) -> Option<(&mut RustObject, &mut ObjectMetadata)> {
        match self {
            Self::Object(obj, meta) => Some((obj, meta)),
            _ => None,
        }
    }

    pub fn into_object(self) -> Option<(RustObject, ObjectMetadata)> {
        match self {
            Self::Object(obj, meta) => Some((obj, meta)),
            _ => None,
        }
    }

    pub fn as_rust_object(&self) -> Option<&RustObject> {
        self.as_object().map(|r| r.0)
    }

    pub fn visit<'a, T: Visit<'a>>(&'a self, visitor: &mut T, usage: ObjectUsage) {
        use RustType::*;
        match self {
            Object(obj, meta) => {
                visitor.visit_obj(obj, Some(meta), usage);
            }
            Simple(_) | Path { .. } => {}
            Container(inner) => visitor.visit_typ(inner.value_typ(), usage),
        }
    }

    pub fn visit_mut<T: VisitMut>(&mut self, visitor: &mut T, usage: ObjectUsage) {
        use RustType::*;
        match self {
            Object(obj, meta) => {
                visitor.visit_obj_mut(obj, Some(meta), usage);
            }
            Simple(_) | Path { .. } => {}
            Container(inner) => visitor.visit_typ_mut(inner.value_typ_mut(), usage),
        }
    }
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum MapKey {
    String,
    Currency,
}

impl Display for MapKey {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str(match self {
            Self::String => "String",
            Self::Currency => ExtType::Currency.ident(),
        })
    }
}

/// Representation of a type containing an inner type.
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum Container {
    /// List<{typ}>
    List(Box<RustType>),
    /// SearchList<{typ}>
    SearchList(Box<RustType>),
    /// Vec<{typ}>
    Vec(Box<RustType>),
    /// &[{typ}]
    Slice(Box<RustType>),
    /// Expandable<{typ}>
    Expandable(Box<RustType>),
    /// Option<{typ}>
    Option(Box<RustType>),
    /// Box<{typ}>
    Box(Box<RustType>),
    /// HashMap<{key}, {typ}>
    Map {
        /// HashMap key type.
        key: MapKey,
        /// HashMap value type.
        value: Box<RustType>,
        /// Are we a reference?
        is_ref: bool,
    },
}

impl Container {
    /// Get a reference to the inner contained type.
    pub fn value_typ(&self) -> &RustType {
        use Container::*;
        match self {
            List(typ) => typ,
            SearchList(typ) => typ,
            Vec(typ) => typ,
            Slice(typ) => typ,
            Expandable(typ) => typ,
            Option(typ) => typ,
            Box(typ) => typ,
            Map { value, .. } => value,
        }
    }

    /// Get a mutable reference to the inner contained type.
    pub fn value_typ_mut(&mut self) -> &mut RustType {
        use Container::*;
        match self {
            List(typ) => typ,
            SearchList(typ) => typ,
            Vec(typ) => typ,
            Slice(typ) => typ,
            Expandable(typ) => typ,
            Option(typ) => typ,
            Box(typ) => typ,
            Map { value, .. } => value,
        }
    }
}

/// Either a Rust defined scalar type, or a type predefined in `stripe_types`.
#[derive(Copy, Clone, Eq, PartialEq, Hash)]
pub enum SimpleType {
    /// bool
    Bool,
    /// f64
    Float,
    /// &str
    Str,
    /// String
    String,
    /// One of primitive rust integer types.
    Int(IntType),
    /// Type defined in `stripe_types`.
    Ext(ExtType),
}

impl SimpleType {
    /// Does this type implement `Copy`?
    pub const fn is_copy(self) -> bool {
        !matches!(self, Self::String | Self::Ext(ExtType::Value))
    }

    /// Is this type a reference?
    pub const fn is_reference(self) -> bool {
        matches!(self, Self::Str)
    }

    pub const fn ident(self) -> &'static str {
        use SimpleType::*;
        match self {
            Bool => "bool",
            Float => "f64",
            String => "String",
            Str => "str",
            Int(typ) => typ.as_str(),
            Ext(ext) => ext.ident(),
        }
    }

    /// Identifier we'll use when this type is part of an enum, e.g.
    /// `Timestamp(stripe_types::Timestamp)`
    pub const fn display_name(self) -> &'static str {
        match self {
            SimpleType::Ext(ext) => ext.display_name(),
            typ => typ.ident(),
        }
    }
}

impl Debug for SimpleType {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str(self.ident())
    }
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum IntType {
    U8,
    U32,
    U64,
    I64,
}

impl IntType {
    pub const fn as_str(self) -> &'static str {
        match self {
            Self::U8 => "u8",
            Self::U32 => "u32",
            Self::U64 => "u64",
            Self::I64 => "i64",
        }
    }
}

impl Display for IntType {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str(self.as_str())
    }
}

/// Types defined outside of codegen.
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ExtType {
    Currency,
    RangeQueryTs,
    Timestamp,
    AlwaysTrue,
    /// Arbitrary JSON value
    Value,
}

impl ExtType {
    pub const fn ident(self) -> &'static str {
        match self {
            Self::Currency => "stripe_types::Currency",
            Self::RangeQueryTs => "stripe_types::RangeQueryTs",
            Self::Timestamp => "stripe_types::Timestamp",
            Self::AlwaysTrue => "stripe_types::AlwaysTrue",
            Self::Value => "miniserde::json::Value",
        }
    }

    pub const fn display_name(self) -> &'static str {
        match self {
            Self::Currency => "Currency",
            Self::RangeQueryTs => "RangeQueryTs",
            Self::Timestamp => "Timestamp",
            Self::AlwaysTrue => "AlwaysTrue",
            Self::Value => "Value",
        }
    }
}

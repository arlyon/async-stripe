# Code Generation
The `openapi` crates handles code generation based on the [Stripe OpenAPI spec](https://github.com/stripe/openapi)

## Running the Binary
The main arguments of interest will be 
- `--fetch`:
  - `current`: Fetch the OpenAPI spec version defined in `version.json`.
  - `latest`: Fetch the latest OpenAPI [release](https://github.com/stripe/openapi/releases)
  - `v{}`: e.g. `v171` - A specific version found in the OpenAPI [release history](https://github.com/stripe/openapi/releases)

Skipping the `--fetch` argument expects an already downloaded spec, useful for quicker development.

- `--graph`: Generates graphs in `graphviz` `DOT` format to aid in understanding autogenerated code:
  - `crate_graph.txt`: Map of crate dependencies
  - `component_graph.txt`: Map of OpenAPI component dependencies
  
`openapi` uses `clap`, so running `cargo run -- --help` will print the documentation of each argument.

## Generated Files
- `generated/*`: Crates including both type definitions and API requests
- `async-stripe-types/generated/*`: Type definitions which are required by `generated/*` crates
- `async-stripe-webhook/generated/*`: Type definitions related to Stripe webhook event deserialization
- `crate_info.md`: A Markdown table explaining which crate contains each Stripe API object

## Generated Crate Organization
This section is not necessary for development, but explains the rationale behind the generated crate
structure. The main annoyance in splitting the generated code into crates is that the Stripe OpenAPI
specification easily creates cyclic dependencies.
For example, a simplified definition of `BalanceTransactionSource` is 
```rust
pub enum BalanceTransactionSource {
  // Many more fields
  IssuingAuthorization(IssuingAuthorization),
  // Many more fields
}
```
`IssuingAuthorization` then completes the cycle:
```rust
pub struct IssuingAuthorization {
    // Many fields
    pub balance_transactions: Vec<BalanceTransaction>,
    // Many fields
}
```
where `BalanceTransaction` is a struct containing a `BalanceTransactionSource` field.

So the only way to avoid a cyclic dependency is for `BalanceTransactionSource` and `IssuingAuthorization`
to live in the same crate.

The solution to avoiding one giant crate was to separate the OpenAPI type definitions from the request
definitions. Every type definition that would result in a cyclic dependency is contained in the
`async-stripe-types` crate, which contains only type definitions (which also allows it to start 
much earlier in a compilation pipeline since it does not depend on the client)

Each of the crates in `generated/*` depends on `async-stripe-types`. Request definitions do not
depend on each other, so each request can live behind its own feature gate, avoiding compilation 
time scaling with the size of the OpenAPI spec.

For a concrete example with `Account`:
- The type definition for `Account` is part of many cycles, so it is defined in `async-stripe-types`.
- The requests related to `Account` (`CreateAccount`, `UpdateAccount`, etc.) are defined in `generated/async-stripe-connect` and gated by the feature `account`.
  - Users not needing those requests can just skip that feature or skip the entire crate if they need nothing from it.
  - `Account` is also reexported in `async-stripe-connect` so that a user does not need to know about crate
  structure, they just need to know everything related to `Account` lives in `async-stripe-connect`

### Special Files
Where possible, keeping hardcoded logic in configuration files read by the code instead of the code
itself is preferred. Currently, these files are:
- `gen_crates.toml`: Specifications for the crates we generate, including which core parts of the 
OpenAPI spec belong in each crate. Modifying this file is how you would change which items are included in which crate, or add additional crate splitting.
